package org.matheclipse.core.reflection.system.rules;

import org.matheclipse.core.interfaces.IAST;

import static org.matheclipse.core.expression.F.Abs;
import static org.matheclipse.core.expression.F.ArcCos;
import static org.matheclipse.core.expression.F.ArcCosh;
import static org.matheclipse.core.expression.F.ArcCot;
import static org.matheclipse.core.expression.F.ArcCoth;
import static org.matheclipse.core.expression.F.ArcCsc;
import static org.matheclipse.core.expression.F.ArcCsch;
import static org.matheclipse.core.expression.F.ArcSec;
import static org.matheclipse.core.expression.F.ArcSech;
import static org.matheclipse.core.expression.F.ArcSin;
import static org.matheclipse.core.expression.F.ArcSinh;
import static org.matheclipse.core.expression.F.ArcTan;
import static org.matheclipse.core.expression.F.ArcTanh;
import static org.matheclipse.core.expression.F.BesselJ;
import static org.matheclipse.core.expression.F.C0;
import static org.matheclipse.core.expression.F.C1;
import static org.matheclipse.core.expression.F.C1D2;
import static org.matheclipse.core.expression.F.C2;
import static org.matheclipse.core.expression.F.CN1;
import static org.matheclipse.core.expression.F.CN1D2;
import static org.matheclipse.core.expression.F.CN2;
import static org.matheclipse.core.expression.F.Ceiling;
import static org.matheclipse.core.expression.F.Cos;
import static org.matheclipse.core.expression.F.Cosh;
import static org.matheclipse.core.expression.F.Cot;
import static org.matheclipse.core.expression.F.Coth;
import static org.matheclipse.core.expression.F.Csc;
import static org.matheclipse.core.expression.F.Csch;
import static org.matheclipse.core.expression.F.DiracDelta;
import static org.matheclipse.core.expression.F.Erf;
import static org.matheclipse.core.expression.F.Erfc;
import static org.matheclipse.core.expression.F.Erfi;
import static org.matheclipse.core.expression.F.Exp;
import static org.matheclipse.core.expression.F.Factorial;
import static org.matheclipse.core.expression.F.Floor;
import static org.matheclipse.core.expression.F.FractionalPart;
import static org.matheclipse.core.expression.F.FresnelC;
import static org.matheclipse.core.expression.F.FresnelS;
import static org.matheclipse.core.expression.F.Gamma;
import static org.matheclipse.core.expression.F.HarmonicNumber;
import static org.matheclipse.core.expression.F.HeavisideTheta;
import static org.matheclipse.core.expression.F.IntegerPart;
import static org.matheclipse.core.expression.F.InverseErf;
import static org.matheclipse.core.expression.F.List;
import static org.matheclipse.core.expression.F.Log;
import static org.matheclipse.core.expression.F.LogisticSigmoid;
import static org.matheclipse.core.expression.F.MeijerG;
import static org.matheclipse.core.expression.F.Negate;
import static org.matheclipse.core.expression.F.Pi;
import static org.matheclipse.core.expression.F.Plus;
import static org.matheclipse.core.expression.F.PolyGamma;
import static org.matheclipse.core.expression.F.Power;
import static org.matheclipse.core.expression.F.ProductLog;
import static org.matheclipse.core.expression.F.QQ;
import static org.matheclipse.core.expression.F.Round;
import static org.matheclipse.core.expression.F.Rule;
import static org.matheclipse.core.expression.F.Sec;
import static org.matheclipse.core.expression.F.Sech;
import static org.matheclipse.core.expression.F.Sin;
import static org.matheclipse.core.expression.F.Sinh;
import static org.matheclipse.core.expression.F.Slot1;
import static org.matheclipse.core.expression.F.Slot2;
import static org.matheclipse.core.expression.F.Sqr;
import static org.matheclipse.core.expression.F.Sqrt;
import static org.matheclipse.core.expression.F.Tan;
import static org.matheclipse.core.expression.F.Tanh;
import static org.matheclipse.core.expression.F.Times;
import static org.matheclipse.core.expression.F.x;

/**
 * <p>Generated by <code>org.matheclipse.core.preprocessor.RulePreprocessor</code>.</p>
 * <p>See GIT repository at: <a href="https://github.com/axkr/symja_android_library">github.com/axkr/symja_android_library under the tools directory</a>.</p>
 */
public interface DerivativeRules {
  final public static IAST RULES1 = List(
    // ArcCos->-1/Sqrt(1-#1^2)
    Rule(ArcCos,
      Negate(Power(Plus(C1,Negate(Sqr(Slot1))),CN1D2))),
    // ArcCosh->1/Sqrt(-1+#1^2)
    Rule(ArcCosh,
      Power(Plus(CN1,Sqr(Slot1)),CN1D2)),
    // ArcCot->1/(-1-#1^2)
    Rule(ArcCot,
      Negate(Power(Plus(C1,Sqr(Slot1)),-1))),
    // ArcCoth->1/(1-#1^2)
    Rule(ArcCoth,
      Power(Plus(C1,Negate(Sqr(Slot1))),-1)),
    // ArcCsc->-1/(#1^2*Sqrt(1-1/#1^2))
    Rule(ArcCsc,
      Times(CN1,Power(Plus(C1,Negate(Power(Slot1,-2))),CN1D2),Power(Slot1,-2))),
    // ArcCsch->-1/(Abs(#1)*Sqrt(1+#1^2))
    Rule(ArcCsch,
      Times(CN1,Power(Abs(Slot1),-1),Power(Plus(C1,Sqr(Slot1)),CN1D2))),
    // ArcSin->1/Sqrt(1-#1^2)
    Rule(ArcSin,
      Power(Plus(C1,Negate(Sqr(Slot1))),CN1D2)),
    // ArcSinh->1/Sqrt(1+#1^2)
    Rule(ArcSinh,
      Power(Plus(C1,Sqr(Slot1)),CN1D2)),
    // ArcTan->1/(1+#1^2)
    Rule(ArcTan,
      Power(Plus(C1,Sqr(Slot1)),-1)),
    // ArcTanh->1/(1-#1^2)
    Rule(ArcTanh,
      Power(Plus(C1,Negate(Sqr(Slot1))),-1)),
    // ArcSec->1/(#1^2*Sqrt(1-1/#1^2))
    Rule(ArcSec,
      Times(Power(Plus(C1,Negate(Power(Slot1,-2))),CN1D2),Power(Slot1,-2))),
    // ArcSech->-1/(#1*Sqrt(1-#1^2))
    Rule(ArcSech,
      Times(CN1,Power(Slot1,-1),Power(Plus(C1,Negate(Sqr(Slot1))),CN1D2))),
    // Ceiling->0
    Rule(Ceiling,
      C0),
    // Erf->2*1/(E^#1^2*Sqrt(Pi))
    Rule(Erf,
      Times(C2,Exp(Negate(Sqr(Slot1))),Power(Pi,CN1D2))),
    // Erfc->-2*1/(E^#1^2*Sqrt(Pi))
    Rule(Erfc,
      Times(CN2,Exp(Negate(Sqr(Slot1))),Power(Pi,CN1D2))),
    // Erfi->2*E^#1^2/Sqrt(Pi)
    Rule(Erfi,
      Times(C2,Exp(Sqr(Slot1)),Power(Pi,CN1D2))),
    // Floor->0
    Rule(Floor,
      C0),
    // FractionalPart->1
    Rule(FractionalPart,
      C1),
    // FresnelC->Cos(1/2*Pi*#1^2)
    Rule(FresnelC,
      Cos(Times(C1D2,Pi,Sqr(Slot1)))),
    // FresnelS->Sin(1/2*Pi*#1^2)
    Rule(FresnelS,
      Sin(Times(C1D2,Pi,Sqr(Slot1)))),
    // Gamma->Gamma(#1)*PolyGamma(#1)
    Rule(Gamma,
      Times(Gamma(Slot1),PolyGamma(Slot1))),
    // HarmonicNumber->Pi^2/6-HarmonicNumber(#1,2)
    Rule(HarmonicNumber,
      Plus(Times(QQ(1L,6L),Sqr(Pi)),Negate(HarmonicNumber(Slot1,C2)))),
    // HeavisideTheta->DiracDelta(#1)
    Rule(HeavisideTheta,
      DiracDelta(Slot1)),
    // IntegerPart->0
    Rule(IntegerPart,
      C0),
    // InverseErf->1/2*Sqrt(Pi)*E^InverseErf(x)^2
    Rule(InverseErf,
      Times(C1D2,Exp(Sqr(InverseErf(x))),Sqrt(Pi))),
    // Log->1/#1
    Rule(Log,
      Power(Slot1,-1)),
    // LogisticSigmoid->LogisticSigmoid(#1)*(1-LogisticSigmoid(#1))
    Rule(LogisticSigmoid,
      Times(Plus(C1,Negate(LogisticSigmoid(Slot1))),LogisticSigmoid(Slot1))),
    // PolyGamma->PolyGamma(1,#1)
    Rule(PolyGamma,
      PolyGamma(C1,Slot1)),
    // Cot->-Csc(#1)^2
    Rule(Cot,
      Negate(Sqr(Csc(Slot1)))),
    // Coth->-1/Sinh(#1)^2
    Rule(Coth,
      Negate(Power(Sinh(Slot1),-2))),
    // Cos->-Sin(#1)
    Rule(Cos,
      Negate(Sin(Slot1))),
    // Cosh->Sinh(#1)
    Rule(Cosh,
      Sinh(Slot1)),
    // Csc->-Cot(#1)*Csc(#1)
    Rule(Csc,
      Times(CN1,Cot(Slot1),Csc(Slot1))),
    // Csch->-Coth(#1)*Csch(#1)
    Rule(Csch,
      Times(CN1,Coth(Slot1),Csch(Slot1))),
    // Round->0
    Rule(Round,
      C0),
    // Sin->Cos(#1)
    Rule(Sin,
      Cos(Slot1)),
    // Sinh->Cosh(#1)
    Rule(Sinh,
      Cosh(Slot1)),
    // Tan->Sec(#1)^2
    Rule(Tan,
      Sqr(Sec(Slot1))),
    // Tanh->Sech(#1)^2
    Rule(Tanh,
      Sqr(Sech(Slot1))),
    // Sec->Sec(#1)*Tan(#1)
    Rule(Sec,
      Times(Sec(Slot1),Tan(Slot1))),
    // Sech->-Tanh(#1)*Sech(#1)
    Rule(Sech,
      Times(CN1,Sech(Slot1),Tanh(Slot1)))
  );
  final public static IAST RULES2 = List(
    // ArcSin->#1/(1-#1^2)^(3/2)
    Rule(ArcSin,
      Times(Slot1,Power(Plus(C1,Negate(Sqr(Slot1))),QQ(-3L,2L)))),
    // Gamma->Gamma(#1)*PolyGamma(#1)^2+Gamma(#1)*PolyGamma(1,#1)
    Rule(Gamma,
      Plus(Times(Gamma(Slot1),PolyGamma(C1,Slot1)),Times(Gamma(Slot1),Sqr(PolyGamma(Slot1))))),
    // Log->-1/#1^2
    Rule(Log,
      Negate(Power(Slot1,-2))),
    // PolyGamma->PolyGamma(2,#1)
    Rule(PolyGamma,
      PolyGamma(C2,Slot1)),
    // Cot->2*Csc(#1)^2*Cot(#1)
    Rule(Cot,
      Times(C2,Cot(Slot1),Sqr(Csc(Slot1)))),
    // Tan->2*Sec(#1)^2*Tan(#1)
    Rule(Tan,
      Times(C2,Sqr(Sec(Slot1)),Tan(Slot1)))
  );
  final public static IAST RULES3 = List(
    // Log->(-1+#2)!/((-1)^(1-#2)*#1^#2)
    Rule(Log,
      Times(Power(CN1,Plus(CN1,Slot2)),Factorial(Plus(CN1,Slot2)),Power(Slot1,Negate(Slot2)))),
    // PolyGamma->PolyGamma(#2,#1)
    Rule(PolyGamma,
      PolyGamma(Slot2,Slot1)),
    // Cos->Cos(#1+1/2*Pi*#2)
    Rule(Cos,
      Cos(Plus(Slot1,Times(C1D2,Pi,Slot2)))),
    // Sin->Sin(#1+1/2*Pi*#2)
    Rule(Sin,
      Sin(Plus(Slot1,Times(C1D2,Pi,Slot2))))
  );
  final public static IAST RULES4 = List(
    // {BesselJ,0,1}->1/2*(BesselJ(-1+#1,#2)-BesselJ(1+#1,#2))
    Rule(List(BesselJ,C0,C1),
      Times(C1D2,Plus(BesselJ(Plus(CN1,Slot1),Slot2),Negate(BesselJ(Plus(C1,Slot1),Slot2))))),
    // {Gamma,0,1}->-E^(-#2)/#2^(1-#1)
    Rule(List(Gamma,C0,C1),
      Times(CN1,Exp(Negate(Slot2)),Power(Slot2,Plus(CN1,Slot1)))),
    // {Gamma,1,0}->Gamma(#1,#2)*Log(#2)+MeijerG({{},{1,1}},{{0,0,#1},{}},#2)
    Rule(List(Gamma,C1,C0),
      Plus(Times(Gamma(Slot1,Slot2),Log(Slot2)),MeijerG(List(List(),List(C1,C1)),List(List(C0,C0,Slot1),List()),Slot2))),
    // {Power,1,0}->#2/#1^(1-#2)
    Rule(List(Power,C1,C0),
      Times(Power(Slot1,Plus(CN1,Slot2)),Slot2)),
    // {Power,0,1}->Log(#1)*#1^#2
    Rule(List(Power,C0,C1),
      Times(Log(Slot1),Power(Slot1,Slot2))),
    // {Power,1,1}->#1^(-1+#2)+(Log(#1)*#2)/#1^(1-#2)
    Rule(List(Power,C1,C1),
      Plus(Power(Slot1,Plus(CN1,Slot2)),Times(Log(Slot1),Power(Slot1,Plus(CN1,Slot2)),Slot2))),
    // {ProductLog,0,1}->ProductLog(#1,#2)/#2*(1+ProductLog(#1,#2))
    Rule(List(ProductLog,C0,C1),
      Times(ProductLog(Slot1,Slot2),Plus(C1,ProductLog(Slot1,Slot2)),Power(Slot2,-1)))
  );
}
