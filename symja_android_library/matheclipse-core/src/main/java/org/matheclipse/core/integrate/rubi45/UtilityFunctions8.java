package org.matheclipse.core.integrate.rubi45;


import static org.matheclipse.core.expression.F.*;
import static org.matheclipse.core.integrate.rubi45.UtilityFunctionCtors.*;

import org.matheclipse.core.interfaces.IAST;
/** 
 * UtilityFunctions rules from the <a href="http://www.apmaths.uwo.ca/~arich/">Rubi -
 * rule-based integrator</a>.
 *  
 */
public class UtilityFunctions8 { 
  public static IAST RULES = List( 
ISetDelayed(UnifyInertTrigFunction(Times(Plus(A_DEFAULT,Times(B_DEFAULT,$($s("§sec"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),Times(C_DEFAULT,Sqr($($s("§sec"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))))),Power(Times(d_DEFAULT,$($s("§sec"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),n_DEFAULT),Power(Plus(a_DEFAULT,Times(b_DEFAULT,$($s("§sec"),Plus(e_DEFAULT,Times(f_DEFAULT,x_))))),m_DEFAULT)),x_),
    Condition(Times(Power(Plus(a,Times(b,$($s("§csc"),Plus(e,Times(C1D2,Pi),Times(f,x))))),m),Power(Times(d,$($s("§csc"),Plus(e,Times(C1D2,Pi),Times(f,x)))),n),Plus(ASymbol,Times(BSymbol,$($s("§csc"),Plus(e,Times(C1D2,Pi),Times(f,x)))),Times(CSymbol,Sqr($($s("§csc"),Plus(e,Times(C1D2,Pi),Times(f,x))))))),FreeQ(List(a,b,d,e,f,ASymbol,BSymbol,CSymbol,m,n),x))),
ISetDelayed(UnifyInertTrigFunction(Times(Plus(A_DEFAULT,Times(C_DEFAULT,Sqr($($s("§sec"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))))),Power(Times(d_DEFAULT,$($s("§sec"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),n_DEFAULT),Power(Plus(a_DEFAULT,Times(b_DEFAULT,$($s("§sec"),Plus(e_DEFAULT,Times(f_DEFAULT,x_))))),m_DEFAULT)),x_),
    Condition(Times(Power(Plus(a,Times(b,$($s("§csc"),Plus(e,Times(C1D2,Pi),Times(f,x))))),m),Power(Times(d,$($s("§csc"),Plus(e,Times(C1D2,Pi),Times(f,x)))),n),Plus(ASymbol,Times(CSymbol,Sqr($($s("§csc"),Plus(e,Times(C1D2,Pi),Times(f,x))))))),FreeQ(List(a,b,d,e,f,ASymbol,CSymbol,m,n),x))),
ISetDelayed(UnifyInertTrigFunction(u_,x_),
    u),
ISetDelayed(UnifyInertTrigFunction(Power(Plus(a_DEFAULT,Times(b_DEFAULT,Power(Times(c_DEFAULT,$($s("§csc"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),n_))),p_),x_),
    Condition(Power(Plus(a,Times(b,Power(Times(CN1,c,$($s("§sec"),Plus(e,Times(C1D2,Pi),Times(f,x)))),n))),p),And(FreeQ(List(a,b,c,e,f,n,p),x),Not(And(EqQ(a,C0),IntegerQ(p)))))),
ISetDelayed(UnifyInertTrigFunction(Times(Power(Times(d_DEFAULT,$($s("§cos"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),m_DEFAULT),Power(Plus(a_DEFAULT,Times(b_DEFAULT,Power(Times(c_DEFAULT,$($s("§csc"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),n_))),p_DEFAULT)),x_),
    Condition(Times(Power(Times(d,$($s("§sin"),Plus(e,Times(C1D2,Pi),Times(f,x)))),m),Power(Plus(a,Times(b,Power(Times(CN1,c,$($s("§sec"),Plus(e,Times(C1D2,Pi),Times(f,x)))),n))),p)),And(FreeQ(List(a,b,c,d,e,f,m,n,p),x),Not(And(EqQ(a,C0),IntegerQ(p)))))),
ISetDelayed(UnifyInertTrigFunction(Times(Power(Plus(a_DEFAULT,Times(b_DEFAULT,Power(Times(c_DEFAULT,$($s("§csc"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),n_))),p_DEFAULT),Power(Times(d_DEFAULT,$($s("§sin"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),m_DEFAULT)),x_),
    Condition(Times(Power(Times(CN1,d,$($s("§cos"),Plus(e,Times(C1D2,Pi),Times(f,x)))),m),Power(Plus(a,Times(b,Power(Times(CN1,c,$($s("§sec"),Plus(e,Times(C1D2,Pi),Times(f,x)))),n))),p)),And(FreeQ(List(a,b,c,d,e,f,m,n,p),x),Not(And(EqQ(a,C0),IntegerQ(p)))))),
ISetDelayed(UnifyInertTrigFunction(Times(Power(Times(d_DEFAULT,$($s("§cot"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),m_DEFAULT),Power(Plus(a_DEFAULT,Times(b_DEFAULT,Power(Times(c_DEFAULT,$($s("§csc"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),n_))),p_DEFAULT)),x_),
    Condition(Times(Power(Times(CN1,d,$($s("§tan"),Plus(e,Times(C1D2,Pi),Times(f,x)))),m),Power(Plus(a,Times(b,Power(Times(CN1,c,$($s("§sec"),Plus(e,Times(C1D2,Pi),Times(f,x)))),n))),p)),And(FreeQ(List(a,b,c,d,e,f,m,n,p),x),Not(And(EqQ(a,C0),IntegerQ(p)))))),
ISetDelayed(UnifyInertTrigFunction(Times(Power(Plus(a_DEFAULT,Times(b_DEFAULT,Power(Times(c_DEFAULT,$($s("§csc"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),n_))),p_DEFAULT),Power(Times(d_DEFAULT,$($s("§tan"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),m_DEFAULT)),x_),
    Condition(Times(Power(Times(CN1,d,$($s("§cot"),Plus(e,Times(C1D2,Pi),Times(f,x)))),m),Power(Plus(a,Times(b,Power(Times(CN1,c,$($s("§sec"),Plus(e,Times(C1D2,Pi),Times(f,x)))),n))),p)),And(FreeQ(List(a,b,c,d,e,f,m,n,p),x),Not(And(EqQ(a,C0),IntegerQ(p)))))),
ISetDelayed(UnifyInertTrigFunction(Times(Power(Times(d_DEFAULT,$($s("§csc"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),m_DEFAULT),Power(Plus(a_DEFAULT,Times(b_DEFAULT,Power(Times(c_DEFAULT,$($s("§csc"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),n_))),p_DEFAULT)),x_),
    Condition(Times(Power(Times(CN1,d,$($s("§sec"),Plus(e,Times(C1D2,Pi),Times(f,x)))),m),Power(Plus(a,Times(b,Power(Times(CN1,c,$($s("§sec"),Plus(e,Times(C1D2,Pi),Times(f,x)))),n))),p)),And(FreeQ(List(a,b,c,d,e,f,m,n,p),x),Not(And(EqQ(n,C2),EqQ(p,C1))),Not(And(EqQ(a,C0),IntegerQ(p)))))),
ISetDelayed(UnifyInertTrigFunction(Times(Power(Plus(a_DEFAULT,Times(b_DEFAULT,Power(Times(c_DEFAULT,$($s("§csc"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),n_))),p_DEFAULT),Power(Times(d_DEFAULT,$($s("§sec"),Plus(e_DEFAULT,Times(f_DEFAULT,x_)))),m_DEFAULT)),x_),
    Condition(Times(Power(Times(d,$($s("§csc"),Plus(e,Times(C1D2,Pi),Times(f,x)))),m),Power(Plus(a,Times(b,Power(Times(CN1,c,$($s("§sec"),Plus(e,Times(C1D2,Pi),Times(f,x)))),n))),p)),And(FreeQ(List(a,b,c,d,e,f,m,n,p),x),Not(And(EqQ(a,C0),IntegerQ(p)))))),
ISetDelayed(KnownSineIntegrandQ(u_,x_Symbol),
    KnownTrigIntegrandQ(List($s("§sin"),$s("§cos")),u,x)),
ISetDelayed(KnownTangentIntegrandQ(u_,x_Symbol),
    KnownTrigIntegrandQ(List($s("§tan")),u,x)),
ISetDelayed(KnownCotangentIntegrandQ(u_,x_Symbol),
    KnownTrigIntegrandQ(List($s("§cot")),u,x)),
ISetDelayed(KnownSecantIntegrandQ(u_,x_Symbol),
    KnownTrigIntegrandQ(List($s("§sec"),$s("§csc")),u,x)),
ISetDelayed(KnownTrigIntegrandQ($p("§list"),u_,x_Symbol),
    Or(SameQ(u,C1),MatchQ(u,Condition(Power(Plus(a_DEFAULT,Times(b_DEFAULT,$($p("func"),Plus(e_DEFAULT,Times(f_DEFAULT,x))))),m_DEFAULT),And(MemberQ($s("§list"),$s("func")),FreeQ(List(a,b,e,f,m),x)))),MatchQ(u,Condition(Times(Power(Plus(a_DEFAULT,Times(b_DEFAULT,$($p("func"),Plus(e_DEFAULT,Times(f_DEFAULT,x))))),m_DEFAULT),Plus(A_DEFAULT,Times(B_DEFAULT,$($p("func"),Plus(e_DEFAULT,Times(f_DEFAULT,x)))))),And(MemberQ($s("§list"),$s("func")),FreeQ(List(a,b,e,f,ASymbol,BSymbol,m),x)))),MatchQ(u,Condition(Plus(A_DEFAULT,Times(C_DEFAULT,Sqr($($p("func"),Plus(e_DEFAULT,Times(f_DEFAULT,x)))))),And(MemberQ($s("§list"),$s("func")),FreeQ(List(e,f,ASymbol,CSymbol),x)))),MatchQ(u,Condition(Plus(A_DEFAULT,Times(B_DEFAULT,$($p("func"),Plus(e_DEFAULT,Times(f_DEFAULT,x)))),Times(C_DEFAULT,Sqr($($p("func"),Plus(e_DEFAULT,Times(f_DEFAULT,x)))))),And(MemberQ($s("§list"),$s("func")),FreeQ(List(e,f,ASymbol,BSymbol,CSymbol),x)))),MatchQ(u,Condition(Times(Power(Plus(a_DEFAULT,Times(b_DEFAULT,$($p("func"),Plus(e_DEFAULT,Times(f_DEFAULT,x))))),m_DEFAULT),Plus(A_DEFAULT,Times(C_DEFAULT,Sqr($($p("func"),Plus(e_DEFAULT,Times(f_DEFAULT,x))))))),And(MemberQ($s("§list"),$s("func")),FreeQ(List(a,b,e,f,ASymbol,CSymbol,m),x)))),MatchQ(u,Condition(Times(Power(Plus(a_DEFAULT,Times(b_DEFAULT,$($p("func"),Plus(e_DEFAULT,Times(f_DEFAULT,x))))),m_DEFAULT),Plus(A_DEFAULT,Times(B_DEFAULT,$($p("func"),Plus(e_DEFAULT,Times(f_DEFAULT,x)))),Times(C_DEFAULT,Sqr($($p("func"),Plus(e_DEFAULT,Times(f_DEFAULT,x))))))),And(MemberQ($s("§list"),$s("func")),FreeQ(List(a,b,e,f,ASymbol,BSymbol,CSymbol,m),x)))))),
ISetDelayed(PiecewiseLinearQ(u_,v_,x_Symbol),
    And(PiecewiseLinearQ(u,x),PiecewiseLinearQ(v,x))),
ISetDelayed(PiecewiseLinearQ(u_,x_Symbol),
    Or(LinearQ(u,x),MatchQ(u,Condition(Log(Times(c_DEFAULT,Power(F_,v_))),And(FreeQ(List(FSymbol,c),x),LinearQ(v,x)))),MatchQ(u,Condition($(F_,$(G_,v_)),And(LinearQ(v,x),MemberQ(List(List($s("ArcTanh"),$s("Tanh")),List($s("ArcTanh"),$s("Coth")),List($s("ArcCoth"),$s("Coth")),List($s("ArcCoth"),$s("Tanh")),List($s("ArcTan"),$s("Tan")),List($s("ArcTan"),$s("Cot")),List($s("ArcCot"),$s("Cot")),List($s("ArcCot"),$s("Tan"))),List(FSymbol,GSymbol))))))),
ISetDelayed(Divides(y_,u_,x_Symbol),
    With(List(Set(v,Simplify(Times(u,Power(y,-1))))),If(FreeQ(v,x),v,False))),
ISetDelayed(DerivativeDivides(y_,u_,x_Symbol),
    If(MatchQ(y,Condition(Times(a_DEFAULT,x),FreeQ(a,x))),False,If(If(PolynomialQ(y,x),And(PolynomialQ(u,x),Equal(Exponent(u,x),Plus(Exponent(y,x),Negate(C1)))),EasyDQ(y,x)),Module(List(Set(v,Block(List(Set($s("§$showsteps"),False)),ReplaceAll(D(y,x),Rule(Sinc(z_),Times(Sin(z),Power(z,-1))))))),If(EqQ(v,C0),False,CompoundExpression(Set(v,Simplify(Times(u,Power(v,-1)))),If(FreeQ(v,x),v,False)))),False))),
ISetDelayed(EasyDQ(Times(u_DEFAULT,Power(x_,m_DEFAULT)),x_Symbol),
    Condition(EasyDQ(u,x),FreeQ(m,x))),
ISetDelayed(EasyDQ(u_,x_Symbol),
    If(Or(AtomQ(u),FreeQ(u,x),Equal(Length(u),C0)),True,If(CalculusQ(u),False,If(Equal(Length(u),C1),EasyDQ(Part(u,C1),x),If(Or(BinomialQ(u,x),ProductOfLinearPowersQ(u,x)),True,If(And(RationalFunctionQ(u,x),SameQ(RationalFunctionExponents(u,x),List(C1,C1))),True,If(ProductQ(u),If(FreeQ(First(u),x),EasyDQ(Rest(u),x),If(FreeQ(Rest(u),x),EasyDQ(First(u),x),False)),If(SumQ(u),And(EasyDQ(First(u),x),EasyDQ(Rest(u),x)),If(Equal(Length(u),C2),If(FreeQ(Part(u,C1),x),EasyDQ(Part(u,C2),x),If(FreeQ(Part(u,C2),x),EasyDQ(Part(u,C1),x),False)),False))))))))),
ISetDelayed(ProductOfLinearPowersQ(u_,x_Symbol),
    Or(FreeQ(u,x),MatchQ(u,Condition(Power(v_,n_DEFAULT),And(LinearQ(v,x),FreeQ(n,x)))),And(ProductQ(u),ProductOfLinearPowersQ(First(u),x),ProductOfLinearPowersQ(Rest(u),x)))),
ISetDelayed(Rt(u_,$p(n, Integer)),
    RtAux(TogetherSimplify(u),n)),
ISetDelayed(NthRoot(u_,n_),
    Power(u,Power(n,-1))),
ISetDelayed(TrigSquare(u_),
    If(SumQ(u),With(List(Set($s("lst"),SplitSum(Function(SplitProduct($s("Integrate::TrigSquareQ"),Slot1)),u))),If(And(Not(AtomQ($s("lst"))),EqQ(Plus(Part($s("lst"),C1,C2),Part($s("lst"),C2)),C0)),If(SameQ(Head(Part(Part($s("lst"),C1,C1),C1)),$s("Sin")),Times(Part($s("lst"),C2),Sqr(Cos(Part(Part($s("lst"),C1,C1),C1,C1)))),Times(Part($s("lst"),C2),Sqr(Sin(Part(Part($s("lst"),C1,C1),C1,C1))))),False)),False)),
ISetDelayed(RtAux(u_,n_),
    If(PowerQ(u),Power(Part(u,C1),Times(Part(u,C2),Power(n,-1))),If(ProductQ(u),Module(List($s("lst")),CompoundExpression(Set($s("lst"),SplitProduct(Function(GtQ(Slot1,C0)),u)),If(ListQ($s("lst")),Times(RtAux(Part($s("lst"),C1),n),RtAux(Part($s("lst"),C2),n)),CompoundExpression(Set($s("lst"),SplitProduct(Function(LtQ(Slot1,C0)),u)),If(ListQ($s("lst")),If(EqQ(Part($s("lst"),C1),CN1),With(List(Set(v,Part($s("lst"),C2))),If(And(PowerQ(v),LtQ(Part(v,C2),C0)),Power(RtAux(Negate(Power(Part(v,C1),Negate(Part(v,C2)))),n),-1),If(ProductQ(v),If(ListQ(SplitProduct($s("Integrate::SumBaseQ"),v)),CompoundExpression(Set($s("lst"),SplitProduct($s("Integrate::AllNegTermQ"),v)),If(ListQ($s("lst")),Times(RtAux(Negate(Part($s("lst"),C1)),n),RtAux(Part($s("lst"),C2),n)),CompoundExpression(Set($s("lst"),SplitProduct($s("Integrate::NegSumBaseQ"),v)),If(ListQ($s("lst")),Times(RtAux(Negate(Part($s("lst"),C1)),n),RtAux(Part($s("lst"),C2),n)),CompoundExpression(Set($s("lst"),SplitProduct($s("Integrate::SomeNegTermQ"),v)),If(ListQ($s("lst")),Times(RtAux(Negate(Part($s("lst"),C1)),n),RtAux(Part($s("lst"),C2),n)),CompoundExpression(Set($s("lst"),SplitProduct($s("Integrate::SumBaseQ"),v)),Times(RtAux(Negate(Part($s("lst"),C1)),n),RtAux(Part($s("lst"),C2),n))))))))),CompoundExpression(Set($s("lst"),SplitProduct($s("Integrate::AtomBaseQ"),v)),If(ListQ($s("lst")),Times(RtAux(Negate(Part($s("lst"),C1)),n),RtAux(Part($s("lst"),C2),n)),Times(RtAux(Negate(First(v)),n),RtAux(Rest(v),n))))),If(OddQ(n),Negate(RtAux(v,n)),NthRoot(u,n))))),Times(RtAux(Negate(Part($s("lst"),C1)),n),RtAux(Negate(Part($s("lst"),C2)),n))),CompoundExpression(Set($s("lst"),SplitProduct($s("Integrate::AllNegTermQ"),u)),If(And(ListQ($s("lst")),ListQ(SplitProduct($s("Integrate::SumBaseQ"),Part($s("lst"),C2)))),Times(RtAux(Negate(Part($s("lst"),C1)),n),RtAux(Negate(Part($s("lst"),C2)),n)),CompoundExpression(Set($s("lst"),SplitProduct($s("Integrate::NegSumBaseQ"),u)),If(And(ListQ($s("lst")),ListQ(SplitProduct($s("Integrate::NegSumBaseQ"),Part($s("lst"),C2)))),Times(RtAux(Negate(Part($s("lst"),C1)),n),RtAux(Negate(Part($s("lst"),C2)),n)),Map(Function(RtAux(Slot1,n)),u)))))))))),With(List(Set(v,TrigSquare(u))),If(Not(AtomQ(v)),RtAux(v,n),If(And(OddQ(n),LtQ(u,C0)),Negate(RtAux(Negate(u),n)),If(ComplexNumberQ(u),With(List(Set(a,Re(u)),Set(b,Im(u))),If(And(Not(And(IntegerQ(a),IntegerQ(b))),IntegerQ(Times(a,Power(Plus(Sqr(a),Sqr(b)),-1))),IntegerQ(Times(b,Power(Plus(Sqr(a),Sqr(b)),-1)))),Power(RtAux(Plus(Times(a,Power(Plus(Sqr(a),Sqr(b)),-1)),Times(CN1,b,Power(Plus(Sqr(a),Sqr(b)),-1),CI)),n),-1),NthRoot(u,n))),If(And(OddQ(n),NegQ(u),PosQ(Negate(u))),Negate(RtAux(Negate(u),n)),NthRoot(u,n))))))))),
ISetDelayed(AtomBaseQ(u_),
    Or(AtomQ(u),And(PowerQ(u),OddQ(Part(u,C2)),AtomBaseQ(Part(u,C1))))),
ISetDelayed(SumBaseQ(u_),
    Or(SumQ(u),And(PowerQ(u),OddQ(Part(u,C2)),SumBaseQ(Part(u,C1))))),
ISetDelayed(NegSumBaseQ(u_),
    Or(And(SumQ(u),NegQ(First(u))),And(PowerQ(u),OddQ(Part(u,C2)),NegSumBaseQ(Part(u,C1))))),
ISetDelayed(AllNegTermQ(u_),
    If(And(PowerQ(u),OddQ(Part(u,C2))),AllNegTermQ(Part(u,C1)),If(SumQ(u),And(NegQ(First(u)),AllNegTermQ(Rest(u))),NegQ(u)))),
ISetDelayed(SomeNegTermQ(u_),
    If(And(PowerQ(u),OddQ(Part(u,C2))),SomeNegTermQ(Part(u,C1)),If(SumQ(u),Or(NegQ(First(u)),SomeNegTermQ(Rest(u))),NegQ(u)))),
ISetDelayed(TrigSquareQ(u_),
    And(PowerQ(u),EqQ(Part(u,C2),C2),MemberQ(List($s("Sin"),$s("Cos")),Head(Part(u,C1))))),
ISetDelayed(SplitProduct($p("func"),u_),
    If(ProductQ(u),If($($s("func"),First(u)),List(First(u),Rest(u)),With(List(Set($s("lst"),SplitProduct($s("func"),Rest(u)))),If(AtomQ($s("lst")),False,List(Part($s("lst"),C1),Times(First(u),Part($s("lst"),C2)))))),If($($s("func"),u),List(u,C1),False))),
ISetDelayed(SplitSum($p("func"),u_),
    If(SumQ(u),If(Not(AtomQ($($s("func"),First(u)))),List($($s("func"),First(u)),Rest(u)),With(List(Set($s("lst"),SplitSum($s("func"),Rest(u)))),If(AtomQ($s("lst")),False,List(Part($s("lst"),C1),Plus(First(u),Part($s("lst"),C2)))))),If(Not(AtomQ($($s("func"),u))),List($($s("func"),u),C0),False))),
ISetDelayed(IntSum(u_,x_Symbol),
    Plus(Simp(Times(FreeTerms(u,x),x),x),IntTerm(NonfreeTerms(u,x),x))),
ISetDelayed(IntTerm(u_,x_Symbol),
    Condition(Map(Function(IntTerm(Slot1,x)),u),SumQ(u))),
ISetDelayed(IntTerm(Times(c_DEFAULT,Power(v_,m_DEFAULT)),x_Symbol),
    Condition(With(List(Set(u,Cancel(v))),If(EqQ(m,CN1),Simp(Times(c,Log(RemoveContent(u,x)),Power(Coeff(u,x,C1),-1)),x),If(And(EqQ(m,C1),EqQ(c,C1),SumQ(u)),IntSum(u,x),Simp(Times(c,Power(u,Plus(m,C1)),Power(Times(Coeff(u,x,C1),Plus(m,C1)),-1)),x)))),And(FreeQ(List(c,m),x),LinearQ(v,x)))),
ISetDelayed(IntTerm(u_,x_Symbol),
    Dist(FreeFactors(u,x),Int(NonfreeFactors(u,x),x),x)),
ISetDelayed(RuleName($p("name")),
    CompoundExpression(AppendTo($s("§$rulenamelist"),$s("name")),Null)),
ISetDelayed(FixIntRules(),
    CompoundExpression(Set($($s("§downvalues"),Integrate),FixIntRules($($s("§downvalues"),Integrate))),Null)),
ISetDelayed(FixIntRules($p("rulelist")),
    Module(List(Set($s("§intdownvalues"),$($s("§downvalues"),Integrate)),Set($s("§substdownvalues"),$($s("§downvalues"),$s("Integrate::Subst"))),Set($s("§simpdownvalues"),$($s("§downvalues"),$s("Integrate::Simp"))),Set($s("§distdownvalues"),$($s("§downvalues"),$s("Integrate::Dist"))),$s("lst")),CompoundExpression(Clear(Integrate,$s("Integrate::Subst"),$s("Integrate::Simp"),$s("Integrate::Dist")),SetAttributes(List($s("Integrate::Simp"),$s("Integrate::Dist"),Integrate,$s("Integrate::Subst")),$s("HoldAll")),Set($s("lst"),Map(Function(FixIntRule(Slot1,Part(Slot1,C1,C1,C2,C1))),$s("rulelist"))),Set($($s("§downvalues"),Integrate),$s("§intdownvalues")),Set($($s("§downvalues"),$s("Integrate::Subst")),$s("§substdownvalues")),Set($($s("§downvalues"),$s("Integrate::Simp")),$s("§simpdownvalues")),Set($($s("§downvalues"),$s("Integrate::Dist")),$s("§distdownvalues")),ClearAttributes(List($s("Integrate::Simp"),$s("Integrate::Dist"),Integrate,$s("Integrate::Subst")),$s("HoldAll")),$s("lst")))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),$(F_,$(G_,$p("§list"),$(F_,Plus(u_,v_),$p("test2"))),$p("test1"))),x_),
    Condition(ReplacePart(RuleDelayed($s("lhs"),F(G($s("§list"),F(Plus(u,v),$s("test2"))),$s("test1"))),List(Rule(List(C2,C1,C2,C1,C1),FixRhsIntRule(u,x)),Rule(List(C2,C1,C2,C1,C2),FixRhsIntRule(v,x)))),And(SameQ(FSymbol,$s("Condition")),Or(SameQ(GSymbol,$s("With")),SameQ(GSymbol,$s("Module")),SameQ(GSymbol,$s("Block")))))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),$(G_,$p("§list"),$(F_,Plus(u_,v_),$p("test2")))),x_),
    Condition(ReplacePart(RuleDelayed($s("lhs"),G($s("§list"),F(Plus(u,v),$s("test2")))),List(Rule(List(C2,C2,C1,C1),FixRhsIntRule(u,x)),Rule(List(C2,C2,C1,C2),FixRhsIntRule(v,x)))),And(SameQ(FSymbol,$s("Condition")),Or(SameQ(GSymbol,$s("With")),SameQ(GSymbol,$s("Module")),SameQ(GSymbol,$s("Block")))))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),$(F_,$(G_,$p("§list"),Plus(u_,v_)),$p("test"))),x_),
    Condition(ReplacePart(RuleDelayed($s("lhs"),F(G($s("§list"),Plus(u,v)),$s("test"))),List(Rule(List(C2,C1,C2,C1),FixRhsIntRule(u,x)),Rule(List(C2,C1,C2,C2),FixRhsIntRule(v,x)))),And(SameQ(FSymbol,$s("Condition")),Or(SameQ(GSymbol,$s("With")),SameQ(GSymbol,$s("Module")),SameQ(GSymbol,$s("Block")))))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),$(G_,$p("§list"),Plus(u_,v_))),x_),
    Condition(ReplacePart(RuleDelayed($s("lhs"),G($s("§list"),Plus(u,v))),List(Rule(List(C2,C2,C1),FixRhsIntRule(u,x)),Rule(List(C2,C2,C2),FixRhsIntRule(v,x)))),Or(SameQ(GSymbol,$s("With")),SameQ(GSymbol,$s("Module")),SameQ(GSymbol,$s("Block"))))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),$(F_,Plus(u_,v_),$p("test"))),x_),
    Condition(ReplacePart(RuleDelayed($s("lhs"),F(Plus(u,v),$s("test"))),List(Rule(List(C2,C1,C1),FixRhsIntRule(u,x)),Rule(List(C2,C1,C2),FixRhsIntRule(v,x)))),SameQ(FSymbol,$s("Condition")))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),Plus(u_,v_)),x_),
    ReplacePart(RuleDelayed($s("lhs"),Plus(u,v)),List(Rule(List(C2,C1),FixRhsIntRule(u,x)),Rule(List(C2,C2),FixRhsIntRule(v,x))))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),$(F_,$(G_,$p("list1"),$(F_,$($p("H"),$p("list2"),u_),$p("test2"))),$p("test1"))),x_),
    Condition(ReplacePart(RuleDelayed($s("lhs"),F(G($s("list1"),F(H($s("list2"),u),$s("test2"))),$s("test1"))),Rule(List(C2,C1,C2,C1,C2),FixRhsIntRule(u,x))),And(SameQ(FSymbol,$s("Condition")),Or(SameQ(GSymbol,$s("With")),SameQ(GSymbol,$s("Module")),SameQ(GSymbol,$s("Block"))),Or(SameQ($s("H"),$s("With")),SameQ($s("H"),$s("Module")),SameQ($s("H"),$s("Block")))))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),$(F_,$(G_,$p("list1"),$($p("H"),$p("list2"),u_)),$p("test1"))),x_),
    Condition(ReplacePart(RuleDelayed($s("lhs"),F(G($s("list1"),H($s("list2"),u)),$s("test1"))),Rule(List(C2,C1,C2,C2),FixRhsIntRule(u,x))),And(SameQ(FSymbol,$s("Condition")),Or(SameQ(GSymbol,$s("With")),SameQ(GSymbol,$s("Module")),SameQ(GSymbol,$s("Block"))),Or(SameQ($s("H"),$s("With")),SameQ($s("H"),$s("Module")),SameQ($s("H"),$s("Block")))))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),$(F_,$(G_,$p("§list"),$(F_,$($p("H"),$p("str1"),$p("str2"),$p("str3"),$($p("J"),u_)),$p("test2"))),$p("test1"))),x_),
    Condition(ReplacePart(RuleDelayed($s("lhs"),F(G($s("§list"),F(H($s("str1"),$s("str2"),$s("str3"),J(u)),$s("test2"))),$s("test1"))),Rule(List(C2,C1,C2,C1,C4,C1),FixRhsIntRule(u,x))),And(SameQ(FSymbol,$s("Condition")),Or(SameQ(GSymbol,$s("With")),SameQ(GSymbol,$s("Module")),SameQ(GSymbol,$s("Block"))),SameQ($s("H"),$s("§showstep")),SameQ($s("J"),$s("Hold"))))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),$(F_,$(G_,$p("§list"),$(F_,u_,$p("test2"))),$p("test1"))),x_),
    Condition(ReplacePart(RuleDelayed($s("lhs"),F(G($s("§list"),F(u,$s("test2"))),$s("test1"))),Rule(List(C2,C1,C2,C1),FixRhsIntRule(u,x))),And(SameQ(FSymbol,$s("Condition")),Or(SameQ(GSymbol,$s("With")),SameQ(GSymbol,$s("Module")),SameQ(GSymbol,$s("Block")))))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),$(G_,$p("§list"),$(F_,u_,$p("test2")))),x_),
    Condition(ReplacePart(RuleDelayed($s("lhs"),G($s("§list"),F(u,$s("test2")))),Rule(List(C2,C2,C1),FixRhsIntRule(u,x))),And(SameQ(FSymbol,$s("Condition")),Or(SameQ(GSymbol,$s("With")),SameQ(GSymbol,$s("Module")),SameQ(GSymbol,$s("Block")))))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),$(F_,$(G_,$p("§list"),u_),$p("test"))),x_),
    Condition(ReplacePart(RuleDelayed($s("lhs"),F(G($s("§list"),u),$s("test"))),Rule(List(C2,C1,C2),FixRhsIntRule(u,x))),And(SameQ(FSymbol,$s("Condition")),Or(SameQ(GSymbol,$s("With")),SameQ(GSymbol,$s("Module")),SameQ(GSymbol,$s("Block")))))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),$(G_,$p("§list"),u_)),x_),
    Condition(ReplacePart(RuleDelayed($s("lhs"),G($s("§list"),u)),Rule(List(C2,C2),FixRhsIntRule(u,x))),Or(SameQ(GSymbol,$s("With")),SameQ(GSymbol,$s("Module")),SameQ(GSymbol,$s("Block"))))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),$(F_,u_,$p("test"))),x_),
    Condition(ReplacePart(RuleDelayed($s("lhs"),F(u,$s("test"))),Rule(List(C2,C1),FixRhsIntRule(u,x))),SameQ(FSymbol,$s("Condition")))),
ISetDelayed(FixIntRule(RuleDelayed($p("lhs"),u_),x_),
    ReplacePart(RuleDelayed($s("lhs"),u),Rule(List(C2),FixRhsIntRule(u,x)))),
ISetDelayed(FixRhsIntRule(Plus(u_,v_),x_),
    Plus(FixRhsIntRule(u,x),FixRhsIntRule(v,x))),
ISetDelayed(FixRhsIntRule(Plus(u_,Negate(v_)),x_),
    Plus(FixRhsIntRule(u,x),Negate(FixRhsIntRule(v,x)))),
ISetDelayed(FixRhsIntRule(Negate(u_),x_),
    Negate(FixRhsIntRule(u,x))),
ISetDelayed(FixRhsIntRule(Times(a_,u_),x_),
    Condition(Dist(a,u,x),MemberQ(List(Integrate,$s("Integrate::Subst")),Head(Unevaluated(u))))),
ISetDelayed(FixRhsIntRule(u_,x_),
    If(And(SameQ(Head(Unevaluated(u)),$s("Integrate::Dist")),Equal(Length(Unevaluated(u)),C2)),Insert(Unevaluated(u),x,C3),If(MemberQ(List(Integrate,$s("Integrate::Unintegrable"),$s("Integrate::CannotIntegrate"),$s("Integrate::Subst"),$s("Integrate::Simp"),$s("Integrate::Dist")),Head(Unevaluated(u))),u,Simp(u,x))))
  );
}
